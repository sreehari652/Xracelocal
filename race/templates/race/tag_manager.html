<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>UWB Race Display - Live Tracking</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  body{background:#0f1117;color:#e2e8f0;font-family:'Segoe UI',sans-serif;height:100vh;display:flex;flex-direction:column;overflow:hidden}
  
  .top{display:flex;align-items:center;gap:8px;padding:10px 12px;background:#1a1d2e;border-bottom:1px solid #2e3148;flex-shrink:0;flex-wrap:wrap}
  .top select{padding:8px 10px;border-radius:6px;border:1px solid #3a3f5c;background:#151720;color:#e2e8f0;font-size:.85rem;min-width:140px;outline:none;cursor:pointer;flex:1 1 auto}
  .top select:focus{border-color:#6c63ff}
  .top button{padding:7px 12px;border-radius:6px;border:none;font-size:.8rem;font-weight:600;cursor:pointer;transition:all .2s;white-space:nowrap}
  .top button:disabled{opacity:.4;cursor:not-allowed}
  .btn-live{background:#16a34a;color:#fff}
  .btn-live:hover:not(:disabled){background:#15803d}
  .btn-finish{background:#dc2626;color:#fff}
  .btn-finish:hover:not(:disabled){background:#b91c1c}
  .status-badge{font-size:.75rem;padding:4px 10px;border-radius:12px;background:#2e3148;color:#94a3b8;font-weight:600;white-space:nowrap}
  .status-badge.live{background:#16a34a33;color:#4ade80}
  .status-badge.finished{background:#7c3aed33;color:#a78bfa}
  .ws-status{font-size:.75rem;padding:4px 10px;border-radius:12px;background:#2e3148;color:#94a3b8}
  .ws-status.connected{background:#16a34a33;color:#4ade80}
  .ws-status.disconnected{background:#dc262633;color:#f87171}
  
  .body{display:flex;flex:1;overflow:hidden}
  .cv-wrap{flex:1;display:flex;align-items:center;justify-content:center;padding:12px;min-height:0}
  canvas{border-radius:8px;border:1px solid #2e3148;background:#151720;max-width:100%;height:auto}
  
  .side{width:300px;background:#1a1d2e;border-left:1px solid #2e3148;overflow-y:auto;padding:12px;flex-shrink:0}
  .side h3{font-size:.9rem;color:#6c63ff;margin-bottom:10px;border-bottom:1px solid #2e3148;padding-bottom:5px}
  
  .stats{background:#151720;border-radius:8px;padding:10px;margin-bottom:12px;border:1px solid #2e3148}
  .stats-row{display:flex;justify-content:space-between;font-size:.75rem;margin-bottom:4px}
  .stats-label{color:#64748b}
  .stats-value{color:#4ade80;font-weight:600}
  
  .card{background:#151720;border-radius:8px;padding:10px 12px;margin-bottom:8px;border-left:4px solid #2e3148;position:relative}
  .card.live{border-left-color:var(--player-color)}
  .card.tracking{animation:pulse 2s infinite}
  .card .name{font-size:.85rem;font-weight:600;color:#fff}
  .card .info{font-size:.72rem;color:#64748b;margin-top:2px}
  .card .position{font-size:.72rem;color:#4ade80;font-weight:600;margin-top:2px}
  .card .tag-badge{display:inline-block;background:#2e3148;color:#94a3b8;padding:2px 6px;border-radius:4px;font-size:.7rem;margin-right:4px}
  .card .status-dot{width:10px;height:10px;border-radius:50%;position:absolute;right:12px;top:12px}
  .tag-input{width:100%;padding:6px 8px;border-radius:4px;border:1px solid #3a3f5c;background:#0f1117;color:#e2e8f0;font-size:.8rem;outline:none;margin-top:4px}
  .tag-input:focus{border-color:#6c63ff}
  .save-ind{font-size:.7rem;color:#64748b;margin-top:2px;text-align:right}
  .save-ind.saving{color:#fbbf24}
  .save-ind.saved{color:#4ade80}
  .ph{color:#4a4f6a;font-size:.85rem;text-align:center;padding:30px 0}
  
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }
  
  @media (max-width: 768px) {
    .body{flex-direction:column}
    .cv-wrap{padding:6px;max-height:45vh}
    .side{width:100%;border-left:none;border-top:1px solid #2e3148}
  }
</style>
</head>
<body>

<div class="top">
  <select id="tSel" onchange="loadGroups()"><option value="">â€” Tournament â€”</option></select>
  <select id="gSel" onchange="selectGroup()" disabled><option value="">â€” Group â€”</option></select>
  <span class="status-badge" id="groupStatus"></span>
  <button class="btn-live" id="btnLive" onclick="markLive()" disabled>â–¶ Live</button>
  <button class="btn-finish" id="btnFinish" onclick="markFinished()" disabled>â¹ Finish</button>
  <span class="ws-status disconnected" id="wsStatus">â— WebSocket</span>
</div>

<div class="body">
  <div class="cv-wrap"><canvas id="c" width="900" height="650"></canvas></div>
  <div class="side">
    <h3>ğŸ“Š System</h3>
    <div class="stats">
      <div class="stats-row">
        <span class="stats-label">WebSocket:</span>
        <span class="stats-value" id="wsState">Connecting...</span>
      </div>
      <div class="stats-row">
        <span class="stats-label">Packets/sec:</span>
        <span class="stats-value" id="pktRate">0</span>
      </div>
      <div class="stats-row">
        <span class="stats-label">Tracking:</span>
        <span class="stats-value" id="trackCount">0</span>
      </div>
    </div>
    
    <h3>ğŸ Players & Tags</h3>
    <div id="lb"><p class="ph">Select a group</p></div>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const BASE = 'https://xraceapi.zyberspace.in';
const API  = { 
  list: BASE+'/api/tournaments/', 
  struct: BASE+'/api/tournament-structure/', 
  players: BASE+'/api/group-players/',
  updateTag: BASE+'/api/update-tag-id/',
  markLive: BASE+'/api/mark-group-live/',      
  markFinish: BASE+'/api/mark-group-finished/'  
};

const WS_URL = 'ws://localhost:8001/';


// Anchor positions (cm) - MATCH YOUR PHYSICAL SETUP!
const ANC = [
  {x:0,   y:0},    // A0
  {x:430, y:0},    // A1
  {x:430, y:470},  // A2
  {x:0,   y:470}   // A3
];

const COLORS = ['#ff4757','#2ed573','#1e90ff','#ffa502','#a55eea','#ff6b81','#26de81','#45aaf2','#fc5c65','#fd79a8'];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let currentGroupId = null;
let currentGroupStatus = null;
let players = [];              // From API: [{player_name, tag_id, gp_id, ...}]
let tagData = {};              // Live tracking: {tag_id: {x, y, trail, lastTime}}
let activeTagIds = new Set();  // Tag IDs currently assigned to players in live group

// Stats
let packetCount = 0;
let packetsPerSec = 0;
let lastSecond = Date.now();
let packetsThisSecond = 0;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CANVAS SETUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let scale, offX, offY;

function calcLayout() {
  const pad = 60;
  const maxX = Math.max(...ANC.map(a => a.x));
  const maxY = Math.max(...ANC.map(a => a.y));
  scale = Math.min((canvas.width - pad*2) / maxX, (canvas.height - pad*2) / maxY) * 0.85;
  offX = (canvas.width - maxX * scale) / 2;
  offY = (canvas.height - maxY * scale) / 2;
}
calcLayout();

function toPixel(cx, cy) {
  return {
    px: offX + cx * scale,
    py: canvas.height - offY - cy * scale  // Y-flip
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRILATERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function trilaterate(ranges) {
  const valid = [];
  ranges.forEach((r, i) => {
    if (r > 0 && i < ANC.length) {
      valid.push({x: ANC[i].x, y: ANC[i].y, r});
    }
  });
  
  if (valid.length < 3) return null;
  
  const [a, b, c] = valid;
  const A = 2 * (b.x - a.x);
  const B = 2 * (b.y - a.y);
  const C = a.r**2 - b.r**2 - a.x**2 + b.x**2 - a.y**2 + b.y**2;
  const D = 2 * (c.x - b.x);
  const E = 2 * (c.y - b.y);
  const F = b.r**2 - c.r**2 - b.x**2 + c.x**2 - b.y**2 + c.y**2;
  
  const den = A * E - B * D;
  if (Math.abs(den) < 0.001) return null;
  
  return {
    x: (C * E - F * B) / den,
    y: (A * F - C * D) / den
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRAW LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Grid
  ctx.strokeStyle = '#1e2130';
  ctx.lineWidth = 1;
  const maxX = Math.max(...ANC.map(a => a.x));
  const maxY = Math.max(...ANC.map(a => a.y));
  
  for (let x = 0; x <= maxX; x += 50) {
    const a = toPixel(x, 0);
    const b = toPixel(x, maxY);
    ctx.beginPath();
    ctx.moveTo(a.px, a.py);
    ctx.lineTo(b.px, b.py);
    ctx.stroke();
  }
  
  for (let y = 0; y <= maxY; y += 50) {
    const a = toPixel(0, y);
    const b = toPixel(maxX, y);
    ctx.beginPath();
    ctx.moveTo(a.px, a.py);
    ctx.lineTo(b.px, b.py);
    ctx.stroke();
  }
  
  // Boundary
  ctx.strokeStyle = '#6c63ff';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ANC.forEach((anc, i) => {
    const p = toPixel(anc.x, anc.y);
    if (i === 0) ctx.moveTo(p.px, p.py);
    else ctx.lineTo(p.px, p.py);
  });
  ctx.closePath();
  ctx.stroke();
  
  // Anchors
  ANC.forEach((anc, i) => {
    const p = toPixel(anc.x, anc.y);
    
    // Dot
    ctx.fillStyle = '#6c63ff';
    ctx.beginPath();
    ctx.arc(p.px, p.py, 7, 0, Math.PI * 2);
    ctx.fill();
    
    // Ring
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(p.px, p.py, 7, 0, Math.PI * 2);
    ctx.stroke();
    
    // Label
    ctx.fillStyle = '#94a3b8';
    ctx.font = 'bold 12px Segoe UI';
    ctx.fillText('A' + i, p.px + 12, p.py - 8);
  });
  
  // Players/Tags - ONLY if group is LIVE and tag has data
  if (currentGroupStatus === 'live') {
    const now = Date.now();
    
    players.forEach((player, idx) => {
      const tid = player.tag_id;
      
      // Skip if no tag assigned or no tracking data
      if (!tid || !tagData[tid]) return;
      
      const data = tagData[tid];
      
      // Skip if stale (>3 seconds old)
      if (now - data.lastTime > 3000) return;
      
      const color = COLORS[idx % COLORS.length];
      const p = toPixel(data.x, data.y);
      
      // Trail
      if (data.trail && data.trail.length > 1) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        data.trail.forEach((pt, i) => {
          const tp = toPixel(pt.x, pt.y);
          if (i === 0) ctx.moveTo(tp.px, tp.py);
          else ctx.lineTo(tp.px, tp.py);
        });
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
      
      // Glow
      ctx.shadowColor = color;
      ctx.shadowBlur = 16;
      
      // Dot
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(p.px, p.py, 13, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.shadowBlur = 0;
      
      // White ring
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(p.px, p.py, 13, 0, Math.PI * 2);
      ctx.stroke();
      
      // Name label
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 14px Segoe UI';
      ctx.textAlign = 'center';
      ctx.fillText(player.player_name, p.px, p.py - 22);
      ctx.textAlign = 'left';
      
      // Pulse
      const pulse = 13 + 4 * Math.sin(Date.now() / 100);
      ctx.strokeStyle = color;
      ctx.globalAlpha = 0.3;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.px, p.py, pulse, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    });
  }
  
  requestAnimationFrame(draw);
}
draw();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WEBSOCKET
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let ws;
let reconnectTimer;

function connectWS() {
  if (ws) ws.close();
  
  console.log('[WS] Connecting to', WS_URL);
  ws = new WebSocket(WS_URL);
  
  ws.onopen = () => {
    console.log('[WS] Connected!');
    document.getElementById('wsStatus').className = 'ws-status connected';
    document.getElementById('wsStatus').textContent = 'â— Connected';
    document.getElementById('wsState').textContent = 'Connected';
    
    if (reconnectTimer) {
      clearTimeout(reconnectTimer);
      reconnectTimer = null;
    }
  };
  
  ws.onclose = () => {
    console.log('[WS] Disconnected');
    document.getElementById('wsStatus').className = 'ws-status disconnected';
    document.getElementById('wsStatus').textContent = 'â— Disconnected';
    document.getElementById('wsState').textContent = 'Disconnected';
    
    if (!reconnectTimer) {
      reconnectTimer = setTimeout(connectWS, 2000);
    }
  };
  
  ws.onerror = (err) => {
    console.error('[WS] Error:', err);
  };
  
  ws.onmessage = (e) => {
    try {
      const msg = JSON.parse(e.data);
      
      if (msg.type === 'connection') {
        console.log('[WS]', msg.message);
        return;
      }
      
      if (msg.type !== 'tag_position') return;
      
      const tid = msg.tag_id;
      
      // â˜…â˜…â˜… KEY FILTER: Only process if this tag is in the active (live) group â˜…â˜…â˜…
      if (!activeTagIds.has(tid)) {
        // Ignore this tag - not in current live group
        return;
      }
      
      // Calculate position
      const pos = trilaterate(msg.range);
      if (!pos) return;
      
      // Initialize if needed
      if (!tagData[tid]) {
        tagData[tid] = {x: 0, y: 0, trail: [], lastTime: 0};
      }
      
      // Update
      tagData[tid].x = pos.x;
      tagData[tid].y = pos.y;
      tagData[tid].lastTime = Date.now();
      
      // Trail (keep last 40 points)
      tagData[tid].trail.push({x: pos.x, y: pos.y});
      if (tagData[tid].trail.length > 40) {
        tagData[tid].trail.shift();
      }
      
      // Stats
      packetCount++;
      packetsThisSecond++;
      
      // Update sidebar
      updateSidebar();
      
    } catch (err) {
      console.error('[WS] Parse error:', err);
    }
  };
}

connectWS();

// Update stats every second
setInterval(() => {
  document.getElementById('pktRate').textContent = packetsThisSecond;
  packetsPerSec = packetsThisSecond;
  packetsThisSecond = 0;
  
  // Count active
  const now = Date.now();
  const active = Object.keys(tagData).filter(tid => 
    activeTagIds.has(parseInt(tid)) && (now - tagData[tid].lastTime) < 3000
  ).length;
  document.getElementById('trackCount').textContent = active;
}, 1000);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// API FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function get(url) {
  try {
    const res = await fetch(url, {credentials: 'include'});
    return await res.json();
  } catch (err) {
    console.error('API Error:', err);
    return {data: []};
  }
}

function getCSRF() {
  const cookie = document.cookie.match(/csrftoken=([^;]+)/);
  return cookie ? cookie[1] : null;
}

async function patchWithCSRF(url, body) {
  const res = await fetch(url, {
    method: 'PATCH',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCSRF()
    },
    credentials: 'include',
    body: JSON.stringify(body)
  });
  return res.json();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TOURNAMENT MANAGEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function loadTournaments() {
  const {data} = await get(API.list);
  const sel = document.getElementById('tSel');
  data.forEach(t => {
    const o = document.createElement('option');
    o.value = t.slug;
    o.textContent = t.name;
    sel.appendChild(o);
  });
}

async function loadGroups() {
  const slug = document.getElementById('tSel').value;
  const gSel = document.getElementById('gSel');
  
  gSel.innerHTML = '<option value="">â€” Group â€”</option>';
  gSel.disabled = true;
  
  currentGroupId = null;
  currentGroupStatus = null;
  players = [];
  activeTagIds.clear();
  
  updateStatusBadge();
  updateButtons();
  renderPlayers();
  
  if (!slug) return;
  
  const {data} = await get(API.struct + '?slug=' + slug);
  if (!data?.rounds) return;
  
  gSel.disabled = false;
  
  data.rounds.forEach(r => {
    const og = document.createElement('optgroup');
    og.label = `Round ${r.round_no} â€” ${r.round_name}${r.is_final ? ' ğŸ†' : ''}`;
    
    r.groups.forEach(g => {
      const o = document.createElement('option');
      o.value = g.group_id;
      o.dataset.status = g.group_status || '';
      o.textContent = g.group_name + (g.group_status ? ` [${g.group_status}]` : '');
      og.appendChild(o);
    });
    
    gSel.appendChild(og);
  });
}

async function selectGroup() {
  const gSel = document.getElementById('gSel');
  currentGroupId = gSel.value;
  
  if (!currentGroupId) {
    players = [];
    currentGroupStatus = null;
    activeTagIds.clear();
    renderPlayers();
    updateStatusBadge();
    updateButtons();
    return;
  }
  
  const selectedOption = gSel.options[gSel.selectedIndex];
  currentGroupStatus = selectedOption.dataset.status || '';
  
  updateStatusBadge();
  updateButtons();
  
  // Load players
  const {data} = await get(API.players + '?group_id=' + currentGroupId);
  players = data;
  
  // Build activeTagIds set
  activeTagIds.clear();
  players.forEach(p => {
    if (p.tag_id) {
      activeTagIds.add(parseInt(p.tag_id));
    }
  });
  
  console.log('[GROUP] Selected:', currentGroupId);
  console.log('[GROUP] Status:', currentGroupStatus);
  console.log('[GROUP] Active Tags:', Array.from(activeTagIds));
  
  renderPlayers();
}

function updateStatusBadge() {
  const badge = document.getElementById('groupStatus');
  
  if (!currentGroupStatus) {
    badge.textContent = '';
    badge.className = 'status-badge';
    return;
  }
  
  badge.textContent = currentGroupStatus.toUpperCase();
  badge.className = 'status-badge ' + currentGroupStatus;
}

function updateButtons() {
  const btnLive = document.getElementById('btnLive');
  const btnFinish = document.getElementById('btnFinish');
  
  if (!currentGroupId) {
    btnLive.disabled = true;
    btnFinish.disabled = true;
    return;
  }
  
  btnLive.disabled = (currentGroupStatus === 'live' || currentGroupStatus === 'finished');
  btnFinish.disabled = (currentGroupStatus !== 'live');
}

async function markLive() {
  if (!currentGroupId) return;
  
  const res = await patchWithCSRF(API.markLive, {group_id: currentGroupId});
  
  if (res.success) {
    currentGroupStatus = 'live';
    updateStatusBadge();
    updateButtons();
    
    const gSel = document.getElementById('gSel');
    const opt = gSel.options[gSel.selectedIndex];
    opt.dataset.status = 'live';
    const baseName = opt.textContent.replace(/\s*\[.*?\]\s*$/, '');
    opt.textContent = baseName + ' [live]';
    
    console.log('[RACE] Group marked LIVE - tracking active for tags:', Array.from(activeTagIds));
  }
}

async function markFinished() {
  if (!currentGroupId) return;
  
  const res = await patchWithCSRF(API.markFinish, {group_id: currentGroupId});
  
  if (res.success) {
    currentGroupStatus = 'finished';
    updateStatusBadge();
    updateButtons();
    
    const gSel = document.getElementById('gSel');
    const opt = gSel.options[gSel.selectedIndex];
    opt.dataset.status = 'finished';
    const baseName = opt.textContent.replace(/\s*\[.*?\]\s*$/, '');
    opt.textContent = baseName + ' [finished]';
    
    console.log('[RACE] Group marked FINISHED');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SIDEBAR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderPlayers() {
  const lb = document.getElementById('lb');
  
  if (!players.length) {
    lb.innerHTML = '<p class="ph">No players in this group</p>';
    return;
  }
  
  const now = Date.now();
  
  lb.innerHTML = players.map((p, idx) => {
    const color = COLORS[idx % COLORS.length];
    const tid = p.tag_id;
    const hasData = tid && tagData[tid];
    const isLive = hasData && (now - tagData[tid].lastTime) < 3000;
    const isTracking = currentGroupStatus === 'live' && isLive;
    
    return `
      <div class="card ${isTracking ? 'live tracking' : ''}" style="--player-color:${color}">
        <div class="status-dot" style="background:${isTracking ? color : '#2e3148'}"></div>
        <div style="flex:1">
          <div class="name">${p.player_name}</div>
          <div class="info">
            ${p.player_status}
            ${tid ? `<span class="tag-badge">Tag ${tid}</span>` : ''}
          </div>
          
          ${currentGroupStatus !== 'live' && currentGroupStatus !== 'finished' ? `
            <input class="tag-input" 
                   type="text" 
                   value="${tid || ''}" 
                   placeholder="Enter Tag ID"
                   data-gp-id="${p.gp_id}"
                   onblur="saveTag(this)"
                   onkeydown="if(event.key==='Enter'){event.preventDefault();saveTag(this)}">
            <div class="save-ind" id="ind-${p.gp_id}"></div>
          ` : ''}
          
          ${isTracking ? `
            <div class="position" id="pos-${tid}">
              x:${tagData[tid].x.toFixed(0)} y:${tagData[tid].y.toFixed(0)}
            </div>
          ` : ''}
          
          ${currentGroupStatus === 'live' && tid && !isLive ? `
            <div class="info" style="color:#fbbf24">Waiting for signal...</div>
          ` : ''}
        </div>
      </div>
    `;
  }).join('');
}

function updateSidebar() {
  // Only update positions, don't re-render entire sidebar
  const now = Date.now();
  
  players.forEach(p => {
    const tid = p.tag_id;
    if (!tid || !tagData[tid]) return;
    
    const el = document.getElementById('pos-' + tid);
    if (el && (now - tagData[tid].lastTime) < 3000) {
      el.textContent = `x:${tagData[tid].x.toFixed(0)} y:${tagData[tid].y.toFixed(0)}`;
    } else if (!el) {
      // First data received - need full re-render to show position
      renderPlayers();
    }
  });
}

async function saveTag(input) {
  const gpId = input.dataset.gpId;
  const tagId = input.value.trim();
  const ind = document.getElementById('ind-' + gpId);
  
  ind.textContent = 'â€¦';
  ind.className = 'save-ind saving';
  
  const res = await patchWithCSRF(API.updateTag, {gp_id: gpId, tag_id: tagId});
  
  if (res.success) {
    ind.textContent = 'âœ“ Saved';
    ind.className = 'save-ind saved';
    setTimeout(() => {
      ind.textContent = '';
      ind.className = 'save-ind';
    }, 2000);
    
    // Update local state
    const player = players.find(p => p.gp_id == gpId);
    if (player) {
      player.tag_id = tagId ? parseInt(tagId) : null;
      
      // Rebuild activeTagIds
      activeTagIds.clear();
      players.forEach(p => {
        if (p.tag_id) activeTagIds.add(parseInt(p.tag_id));
      });
      
      console.log('[TAG] Updated - Active tags:', Array.from(activeTagIds));
    }
  } else {
    ind.textContent = 'âœ— Error';
    ind.className = 'save-ind saving';
    setTimeout(() => {
      ind.textContent = '';
      ind.className = 'save-ind';
    }, 2500);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
loadTournaments();

console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
console.log('UWB Race Display - Live Tracking');
console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
console.log('1. Select tournament and group');
console.log('2. Assign tag IDs to players');
console.log('3. Click "â–¶ Live" to start tracking');
console.log('4. Watch real-time positions on canvas!');
console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
</script>
</body>
</html>
